<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Kaylee Hinton</title>
        <link rel="stylesheet" href="style.css">
    </head>

    <body>
        <nav class="navbar">
            <div class="brand">
                <a href="index.html"><img src="artwork/logo.png" alt="Personal Logo" class="logo"></a>
                <span class="name">Kaylee Hinton</span>
            </div>

            <ul id="nav">
                <li><a href="index.html"> Home </a></li>
                <li><a href="portfolio.html"> Portfolio </a></li> <!--go to a page with different places to click for each group instead of drop down-->
                <li><a href="tools.html"> Design Tools </a></li> <!-- Follow Portfolio layout-->
                <li><a href="about.html">About</a></li>
            </ul>
        </nav>
    
        <div id="pagewrap">

            <div class="palette">

                <div id="harmonyOptions">
                    <select id="harmonySelect">
                        <option value="none">Random</option>
                        <option value="analogous">Analogous</option>
                        <option value="complementary">Complementary</option>
                        <option value="dscomplementary">Double Split Complementary</option>
                        <option value="rectangle">Rectangle</option>
                        <option value="splitcomplementary">Split Complementary</option>
                        <option value="tetradic">Tetradic</option>
                        <option value="triad">Triad</option>
                    </select>
                </div>

                <button id="generateButton">Generate</button>

                <div class="colors">
                    <div class="color-container">
                        <h4 class="hex">#1234</h4>
                        <div class="color"></div>
                        <div class="lock-wrap">
                            <img class="lock-icon" src="artwork/Lock.png">
                        </div>
                    </div>

                    <div class="color-container">
                        <h4 class="hex">#1234</h4>
                        <div class="color"></div>
                        <div class="lock-wrap">
                            <img class="lock-icon" src="artwork/Lock.png">
                        </div>
                    </div>

                    <div class="color-container">
                        <h4 class="hex">#1234</h4>
                        <div class="color"></div>
                        <div class="lock-wrap">
                            <img class="lock-icon" src="artwork/Lock.png">
                        </div>
                    </div>

                    <div class="color-container">
                        <h4 class="hex">#1234</h4>
                        <div class="color"></div>
                        <div class="lock-wrap">
                            <img class="lock-icon" src="artwork/Lock.png">
                        </div>
                    </div>

                    <div class="color-container">
                        <h4 class="hex">#1234</h4>
                        <div class="color"></div>
                        <div class="lock-wrap">
                            <img class="lock-icon" src="artwork/Lock.png">
                        </div>
                    </div>
                </div>
            </div>

            <div id="customColorPicker">

                <canvas id="colorCanvas" width="220" height="200"></canvas>

                    <div class="hue-slider">
                        <div class="hue-bar"></div>
                        <div class="hue-handle"></div>

                    </div>

                    <div id="previewColor" class="preview-row"></div>

                        <button id="confirmColor">Confirm</button>
            </div>

            <script>
                const colorContainers = document.querySelectorAll('.colors > div');
                const colorBlocks = document.querySelectorAll('.color');
                const hexLabels = document.querySelectorAll('.hex');
                const generateButton = document.getElementById('generateButton');
                const confirmButton = document.getElementById('confirmColor')
                const harmonySelect = document.getElementById('harmonySelect')

                const popup = document.getElementById("customColorPicker");
                const canvas = document.getElementById("colorCanvas");
                const ctx = canvas.getContext('2d');
                const previewBox = document.getElementById("previewColor");
                const hueBar = document.querySelector('.hue-bar')
                const hueHandle = document.querySelector('.hue-handle')

                const lockImg = 'artwork/Lock.png';

                let selectedBox = null;
                let selectedIndex = null;
                let hue = 0;
                let dragging = false;
                let currentBaseColor = null;
                let complementaryPair = null;

                let locked = Array(colorBlocks.length).fill(false);

                hueHandle.addEventListener('mousedown', () => dragging = true);
                document.addEventListener('mouseup', () => dragging = false);

                colorContainers.forEach((container, i) => {
                    const lockWrap = container.querySelector('.lock-wrap');
                    const colorBlock = container.querySelector('.color');

                    lockWrap.addEventListener('click', (e) => {
                        e.stopPropagation();
                        locked[i] = !locked[i];

                        if (locked[i]) {
                            container.classList.add('locked');
                        } else {
                            container.classList.remove('locked');
                        }
                    });

                    colorBlock.addEventListener('click', () => {
                        if(!locked[i]) openPicker(colorBlock, i);
                    }); 
                });

                // Random color generation
                function generateColors() {
                    colorContainers.forEach(c => c.style.display = 'block');
                    colorBlocks.forEach((block, i) => {
                        if (!locked[i]) {
                            const randomColor = "#" + Math.floor(Math.random() * 16777215).toString(16).padStart(6, "0").toUpperCase();

                            colorBlocks[i].style.background = randomColor;

                            hexLabels[i].textContent = randomColor;
                        }
                    });
                }
                
                function analogousColors() {
                    let baseColor;
                    const lockedIndices = [0, 1, 2, 3, 4].filter(i => locked[i]);

                    if (lockedIndices.length > 1) {
                        alert("Analogous palette can only use 1 locked color. Please unlock others.")
                        return;
                    }

                    let lockedIndex = null;

                    if (lockedIndices.length === 1) {
                        lockedIndex = lockedIndices[0];
                        baseColor = hexLabels[lockedIndex].textContent;

                        locked[lockedIndex] = false;
                        colorContainers[lockedIndex].classList.remove('locked');
                        locked[0] = true;
                    } else {
                        const r = Math.floor(Math.random() * 256);
                        const g = Math.floor(Math.random() * 256);
                        const b = Math.floor(Math.random() * 256)
                        baseColor = `rgb(${r}, ${g}, ${b})`;
                        locked[0] = false;
                    }

                    let baseR, baseG, baseB;

                    if (baseColor.startsWith('#')) {
                        const bigint = parseInt(baseColor.slice(1), 16);
                        baseR = (bigint >> 16) & 255;
                        baseG = (bigint >> 8) & 255;
                        baseB = bigint & 255;
                    } else {
                        [baseR, baseG, baseB] = baseColor.match(/\d+/g).map(Number);
                    }

                    const hsl = rgbToHsl(baseR, baseG, baseB);

                    const analogous1 = hslToRgb((hsl.h + 30) % 360, hsl.s, hsl.l);
                    const analogous2 = hslToRgb((hsl.h + 330) % 360, hsl.s, hsl.l);

                    analogousPair = [
                        { r: baseR, g: baseG, b: baseB },
                        { r: analogous1.r, g: analogous1.g, b: analogous1.b},
                        { r: analogous2.r, g: analogous2.g, b: analogous2.b }
                    ];

                    colorContainers.forEach(c => c.style.display = 'none');

                    for (let i = 0; i < analogousPair.length; i++) {
                        const container = colorContainers[i];
                        const block = colorBlocks[i];
                        const label = hexLabels[i];

                        container.style.display = 'block';

                        const color = analogousPair[i];
                        block.style.background = `rgb(${color.r}, ${color.g}, ${color.b})`;
                        label.textContent = rgbToHex(color.r, color.g, color.b);

                        if (i ===0 && lockedIndex !== null) {
                            container.classList.add('locked');
                        } else {
                            container.classList.remove('locked');
                        }
                    }

                    for (let i = analogousPair.length; i < colorContainers.length; i++) {
                        colorContainers[i].style.display = 'none';
                    }
                }

                // Complementary color generation
                function complementaryColors() {
                    let baseColor;
                    const lockedIndices = [0, 1, 2, 3, 4].filter(i => locked[i]);

                    if (lockedIndices.length > 1) {
                        alert("Complementary palette can only use 1 locked color. Please unlock others.");
                        return;
                    }

                    let lockedIndex = null;

                    if (lockedIndices.length === 1) {
                        lockedIndex = lockedIndices[0];
                        baseColor = hexLabels[lockedIndices[0]].textContent;

                        locked[lockedIndex] = false;
                        colorContainers[lockedIndex].classList.remove('locked');
                        locked[0] = true;

                    } else {
                        const r = Math.floor(Math.random() * 256);
                        const g = Math.floor(Math.random() * 256);
                        const b = Math.floor(Math.random() * 256);
                        baseColor = `rgb(${r}, ${g}, ${b})`;

                        locked[0] = false;
                    }

                    let baseR, baseG, baseB;

                    if (baseColor.startsWith('#')) {
                        const bigint = parseInt(baseColor.slice(1), 16);
                        baseR = (bigint >> 16) & 255;
                        baseG = (bigint >> 8) & 255;
                        baseB = bigint & 255;
                    } else {
                        [baseR, baseG, baseB] = baseColor.match(/\d+/g).map(Number);
                    }

                    const hsl = rgbToHsl(baseR, baseG, baseB);
                    const compH = (hsl.h + 180) % 360;
                    const compRgb = hslToRgb(compH, hsl.s, hsl.l);

                    let complementaryPair = [
                        { r: baseR, g: baseG, b: baseB },
                        { r: compRgb.r, g: compRgb.g, b: compRgb.b }
                    ];

                    colorContainers.forEach(c => c.style.display = 'none');

                    for (let i = 0; i < 2; i++) {
                        const container = colorContainers[i];
                        const block = colorBlocks[i];
                        const label = hexLabels[i];

                        container.style.display = 'block';

                        const color = complementaryPair[i];

                        block.style.background = `rgb(${color.r}, ${color.g}, ${color.b})`;
                        label.textContent = rgbToHex(color.r, color.g, color.b);

                        if (i === 0 && lockedIndex !== null) {
                            container.classList.add('locked');
                        } else {
                        container.classList.remove('locked');
                        }
                    }

                    for (let i = 2; i < colorContainers.length; i++) {
                        colorContainers[i].style.display = 'none';
                    }
                }

                // Double Split Complementary
                function doubleSplitComplementaryColors() {
                    let baseColor;
                    const lockedIndices = [0, 1, 2, 3, 4].filter(i => locked[i]);

                    if (lockedIndices.length > 1) {
                        alert("Double Split Complementary palette can only use 1 locked color. Please unlock others.")
                        return;
                    }

                    let lockedIndex = null;

                    if (lockedIndices.length === 1) {
                        lockedIndex = lockedIndices[0];
                        baseColor = hexLabels[lockedIndex].textContent;

                        locked[lockedIndex] = false;
                        colorContainers[lockedIndex].classList.remove('locked');
                        locked[0] = true;
                    } else {
                        const r = Math.floor(Math.random() * 256);
                        const g = Math.floor(Math.random() * 256);
                        const b = Math.floor(Math.random() * 256)
                        baseColor = `rgb(${r}, ${g}, ${b})`;
                        locked[0] = false;
                    }

                    let baseR, baseG, baseB;

                    if (baseColor.startsWith('#')) {
                        const bigint = parseInt(baseColor.slice(1), 16);
                        baseR = (bigint >> 16) & 255;
                        baseG = (bigint >> 8) & 255;
                        baseB = bigint & 255;
                    } else {
                        [baseR, baseG, baseB] = baseColor.match(/\d+/g).map(Number);
                    }

                    const hsl = rgbToHsl(baseR, baseG, baseB);

                    const dsc1 = hslToRgb((hsl.h + 150) % 360, hsl.s, hsl.l);
                    const dsc2 = hslToRgb((hsl.h + 210) % 360, hsl.s, hsl.l);
                    const dsc3 = hslToRgb((hsl.h + 330) % 360, hsl.s, hsl.l);
                    const dsc4 = hslToRgb((hsl.h + 30) % 360, hsl.s, hsl.l);

                    const dscPair = [
                        { r: baseR, g: baseG, b: baseB },
                        { r: dsc1.r, g: dsc1.g, b: dsc1.b},
                        { r: dsc2.r, g: dsc2.g, b: dsc2.b },
                        { r: dsc3.r, g: dsc3.g, b: dsc3.b },
                        { r: dsc4.r, g: dsc4.g, b: dsc4.b },
                    ];
                    
                    colorContainers.forEach(c => c.style.display = 'none');

                    for (let i = 0; i < dscPair.length; i++) {
                        const container = colorContainers[i];
                        const block = colorBlocks[i];
                        const label = hexLabels[i];

                        container.style.display = 'block';

                        const color = dscPair[i];
                        block.style.background = `rgb(${color.r}, ${color.g}, ${color.b})`;
                        label.textContent = rgbToHex(color.r, color.g, color.b);

                        if (i ===0 && lockedIndex !== null) {
                            container.classList.add('locked');
                        } else {
                            container.classList.remove('locked');
                        }
                    }

                    for (let i = dscPair.length; i < colorContainers.length; i++) {
                        colorContainers[i].style.display = 'none';
                    }
                }

                function rectangleColors() {
                    let baseColor;
                    const lockedIndices = [0, 1, 2, 3, 4].filter(i => locked[i]);

                    if (lockedIndices.length > 1) {
                        alert("Rectangle palette can only use 1 locked color. Please unlock others.")
                        return;
                    }

                    let lockedIndex = null;

                    if (lockedIndices.length === 1) {
                        lockedIndex = lockedIndices[0];
                        baseColor = hexLabels[lockedIndex].textContent;

                        locked[lockedIndex] = false;
                        colorContainers[lockedIndex].classList.remove('locked');
                        locked[0] = true;
                    } else {
                        const r = Math.floor(Math.random() * 256);
                        const g = Math.floor(Math.random() * 256);
                        const b = Math.floor(Math.random() * 256)
                        baseColor = `rgb(${r}, ${g}, ${b})`;
                        locked[0] = false;
                    }

                    let baseR, baseG, baseB;

                    if (baseColor.startsWith('#')) {
                        const bigint = parseInt(baseColor.slice(1), 16);
                        baseR = (bigint >> 16) & 255;
                        baseG = (bigint >> 8) & 255;
                        baseB = bigint & 255;
                    } else {
                        [baseR, baseG, baseB] = baseColor.match(/\d+/g).map(Number);
                    }

                    const hsl = rgbToHsl(baseR, baseG, baseB);

                    const rect1 = hslToRgb((hsl.h + 60) % 360, hsl.s, hsl.l);
                    const rect2 = hslToRgb((hsl.h + 180) % 360, hsl.s, hsl.l);
                    const rect3 = hslToRgb((hsl.h + 240) % 360, hsl.s, hsl.l);

                    rectPair = [
                        { r: baseR, g: baseG, b: baseB },
                        { r: rect1.r, g: rect1.g, b: rect1.b},
                        { r: rect2.r, g: rect2.g, b: rect2.b },
                        { r: rect3.r, g: rect3.g, b: rect3.b },
                    ];
                    
                    colorContainers.forEach(c => c.style.display = 'none');

                    for (let i = 0; i < rectPair.length; i++) {
                        const container = colorContainers[i];
                        const block = colorBlocks[i];
                        const label = hexLabels[i];

                        container.style.display = 'block';

                        const color = rectPair[i];
                        block.style.background = `rgb(${color.r}, ${color.g}, ${color.b})`;
                        label.textContent = rgbToHex(color.r, color.g, color.b);

                        if (i ===0 && lockedIndex !== null) {
                            container.classList.add('locked');
                        } else {
                            container.classList.remove('locked');
                        }
                    }

                    for (let i = rectPair.length; i < colorContainers.length; i++) {
                        colorContainers[i].style.display = 'none';
                    }
                }


                function splitComplementaryColors() {
                    let baseColor;
                    const lockedIndices = [0, 1, 2, 3, 4].filter(i => locked[i]);

                    if (lockedIndices.length > 1) {
                        alert("Split Complementary palette can only use 1 locked color. Please unlock others.")
                        return;
                    }

                    let lockedIndex = null;

                    if (lockedIndices.length === 1) {
                        lockedIndex = lockedIndices[0];
                        baseColor = hexLabels[lockedIndex].textContent;

                        locked[lockedIndex] = false;
                        colorContainers[lockedIndex].classList.remove('locked');
                        locked[0] = true;
                    } else {
                        const r = Math.floor(Math.random() * 256);
                        const g = Math.floor(Math.random() * 256);
                        const b = Math.floor(Math.random() * 256)
                        baseColor = `rgb(${r}, ${g}, ${b})`;
                        locked[0] = false;
                    }

                    let baseR, baseG, baseB;

                    if (baseColor.startsWith('#')) {
                        const bigint = parseInt(baseColor.slice(1), 16);
                        baseR = (bigint >> 16) & 255;
                        baseG = (bigint >> 8) & 255;
                        baseB = bigint & 255;
                    } else {
                        [baseR, baseG, baseB] = baseColor.match(/\d+/g).map(Number);
                    }

                    const hsl = rgbToHsl(baseR, baseG, baseB);

                    const sc1 = hslToRgb((hsl.h + 150) % 360, hsl.s, hsl.l);
                    const sc2 = hslToRgb((hsl.h + 210) % 360, hsl.s, hsl.l);

                    const scPair = [
                        { r: baseR, g: baseG, b: baseB },
                        { r: sc1.r, g: sc1.g, b: sc1.b},
                        { r: sc2.r, g: sc2.g, b: sc2.b }
                    ];
                    
                    colorContainers.forEach(c => c.style.display = 'none');

                    for (let i = 0; i < scPair.length; i++) {
                        const container = colorContainers[i];
                        const block = colorBlocks[i];
                        const label = hexLabels[i];

                        container.style.display = 'block';

                        const color = scPair[i];
                        block.style.background = `rgb(${color.r}, ${color.g}, ${color.b})`;
                        label.textContent = rgbToHex(color.r, color.g, color.b);

                        if (i ===0 && lockedIndex !== null) {
                            container.classList.add('locked');
                        } else {
                            container.classList.remove('locked');
                        }
                    }

                    for (let i = scPair.length; i < colorContainers.length; i++) {
                        colorContainers[i].style.display = 'none';
                    }
                }

                function tetradicColors() {
                    let baseColor;
                    const lockedIndices = [0, 1, 2, 3, 4].filter(i => locked[i]);

                    if (lockedIndices.length > 1) {
                        alert("Tetradic palette can only use 1 locked color. Please unlock others.")
                        return;
                    }

                    let lockedIndex = null;

                    if (lockedIndices.length === 1) {
                        lockedIndex = lockedIndices[0];
                        baseColor = hexLabels[lockedIndex].textContent;

                        locked[lockedIndex] = false;
                        colorContainers[lockedIndex].classList.remove('locked');
                        locked[0] = true;
                    } else {
                        const r = Math.floor(Math.random() * 256);
                        const g = Math.floor(Math.random() * 256);
                        const b = Math.floor(Math.random() * 256)
                        baseColor = `rgb(${r}, ${g}, ${b})`;
                        locked[0] = false;
                    }

                    let baseR, baseG, baseB;

                    if (baseColor.startsWith('#')) {
                        const bigint = parseInt(baseColor.slice(1), 16);
                        baseR = (bigint >> 16) & 255;
                        baseG = (bigint >> 8) & 255;
                        baseB = bigint & 255;
                    } else {
                        [baseR, baseG, baseB] = baseColor.match(/\d+/g).map(Number);
                    }

                    const hsl = rgbToHsl(baseR, baseG, baseB);

                    const tetradic1 = hslToRgb((hsl.h + 60) % 360, hsl.s, hsl.l);
                    const tetradic2 = hslToRgb((hsl.h + 180) % 360, hsl.s, hsl.l);
                    const tetradic3 = hslToRgb((hsl.h + 240) % 360, hsl.s, hsl.l);

                    const tetradicPair = [
                        { r: baseR, g: baseG, b: baseB },
                        { r: tetradic1.r, g: tetradic1.g, b: tetradic1.b},
                        { r: tetradic2.r, g: tetradic2.g, b: tetradic2.b },
                        { r: tetradic3.r, g: tetradic3.g, b: tetradic3.b },
                    ];
                    
                    colorContainers.forEach(c => c.style.display = 'none');

                    for (let i = 0; i < tetradicPair.length; i++) {
                        const container = colorContainers[i];
                        const block = colorBlocks[i];
                        const label = hexLabels[i];

                        container.style.display = 'block';

                        const color = tetradicPair[i];
                        block.style.background = `rgb(${color.r}, ${color.g}, ${color.b})`;
                        label.textContent = rgbToHex(color.r, color.g, color.b);

                        if (i ===0 && lockedIndex !== null) {
                            container.classList.add('locked');
                        } else {
                            container.classList.remove('locked');
                        }
                    }

                    for (let i = tetradicPair.length; i < colorContainers.length; i++) {
                        colorContainers[i].style.display = 'none';
                    }
                }

                function triadColors() {
                    let baseColor;
                    const lockedIndices = [0, 1, 2, 3, 4].filter(i => locked[i]);

                    if (lockedIndices.length > 1) {
                        alert("Triad palette can only use 1 locked color. Please unlock others.")
                        return;
                    }

                    let lockedIndex = null;

                    if (lockedIndices.length === 1) {
                        lockedIndex = lockedIndices[0];
                        baseColor = hexLabels[lockedIndex].textContent;

                        locked[lockedIndex] = false;
                        colorContainers[lockedIndex].classList.remove('locked');
                        locked[0] = true;
                    } else {
                        const r = Math.floor(Math.random() * 256);
                        const g = Math.floor(Math.random() * 256);
                        const b = Math.floor(Math.random() * 256)
                        baseColor = `rgb(${r}, ${g}, ${b})`;
                        locked[0] = false;
                    }

                    let baseR, baseG, baseB;

                    if (baseColor.startsWith('#')) {
                        const bigint = parseInt(baseColor.slice(1), 16);
                        baseR = (bigint >> 16) & 255;
                        baseG = (bigint >> 8) & 255;
                        baseB = bigint & 255;
                    } else {
                        [baseR, baseG, baseB] = baseColor.match(/\d+/g).map(Number);
                    }

                    const hsl = rgbToHsl(baseR, baseG, baseB);

                    const triad1 = hslToRgb((hsl.h + 120) % 360, hsl.s, hsl.l);
                    const triad2 = hslToRgb((hsl.h + 240) % 360, hsl.s, hsl.l);

                    triadPair = [
                        { r: baseR, g: baseG, b: baseB },
                        { r: triad1.r, g: triad1.g, b: triad1.b},
                        { r: triad2.r, g: triad2.g, b: triad2.b }
                    ];
                    
                    colorContainers.forEach(c => c.style.display = 'none');

                    for (let i = 0; i < triadPair.length; i++) {
                        const container = colorContainers[i];
                        const block = colorBlocks[i];
                        const label = hexLabels[i];

                        container.style.display = 'block';

                        const color = triadPair[i];
                        block.style.background = `rgb(${color.r}, ${color.g}, ${color.b})`;
                        label.textContent = rgbToHex(color.r, color.g, color.b);

                        if (i ===0 && lockedIndex !== null) {
                            container.classList.add('locked');
                        } else {
                            container.classList.remove('locked');
                        }
                    }

                    for (let i = triadPair.length; i < colorContainers.length; i++) {
                        colorContainers[i].style.display = 'none';
                    }
                }

                generateButton.addEventListener('click', () => {
                    if (harmonySelect.value === 'analogous') {
                        analogousColors();

                    } else if (harmonySelect.value === 'complementary') {
                        complementaryColors();
                    
                    } else if (harmonySelect.value === 'dscomplementary') {
                        doubleSplitComplementaryColors();

                    } else if (harmonySelect.value === 'rectangle') {
                        rectangleColors();
                    
                    } else if (harmonySelect.value === 'splitcomplementary') {
                        splitComplementaryColors();
                    
                    } else if (harmonySelect.value === 'tetradic') {
                        tetradicColors();

                    } else if (harmonySelect.value === 'triad') {
                        triadColors();

                    } else {
                        generateColors();
                    }
                });

                function rgbToHsl(r, g, b) {
                    r /= 255; g /= 255; b /= 255;
                    const max = Math.max(r, g, b), min = Math.min(r, g, b);
                    let h, s, l = (max + min) / 2;

                    if (max === min) h = s = 0;
                    else {
                        const d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                        switch(max){
                            case r: h = ((g - b) / d + (g < b ? 6 : 0)); break;
                            case g: h = ((b - r) / d + 2); break;
                            case b: h = ((r - g) / d + 4); break;
                        }
                        h /= 6;
                    }
                    return{h: h*360, s: s, l: l};
                }

                function hslToRgb(h, s, l){
                    h /= 360;
                    let r, g, b;

                    if(s === 0) r = g = b = l;
                    else {
                        const hue2rgb = (p, q, t) => {
                            if(t < 0) t += 1;
                            if(t > 1) t -= 1;
                            if(t < 1/6) return p + (q - p) * 6 * t;
                            if(t < 1/2) return q;
                            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                            return p;
                        }

                        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        const p = 2 * l - q;

                        r = hue2rgb(p, q, h + 1/3);
                        g = hue2rgb(p, q, h);
                        b = hue2rgb(p , q, h - 1/3);
                    }
                    return { r: Math.round(r*255), g: Math.round(g*255), b: Math.round(b*255) };
                }

                function openPicker(block, index) {
                    selectedBox = block;
                    selectedIndex = index;

                    popup.style.display = 'block';
                    const rect = block.getBoundingClientRect();

                    const popupHeight = popup.offsetHeight;
                    popup.style.top = rect.top + window.scrollY - popupHeight + 'px';
                    popup.style.left = rect.left + window.scrollX + 'px';

                    selectedColor = window.getComputedStyle(block).backgroundColor;
                    updatePreviewColor(...selectedColor.match(/\d+/g).map(Number));

                    currentBaseColor = selectedColor;
                    
                    drawSpectrum();
                }

                function drawSpectrum() {
                    const width = canvas.width;
                    const height = canvas.height;

                    let [r, g, b] = hueToRgb(hue);
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(0, 0, width, height);

                    const whiteGradient = ctx.createLinearGradient(0, 0, width, 0);
                    whiteGradient.addColorStop(0, "white");
                    whiteGradient.addColorStop(1, "rgba(255, 255, 255, 0)");
                    ctx.fillStyle = whiteGradient;
                    ctx.fillRect(0, 0, width, height);

                    const blackGradient = ctx.createLinearGradient(0, 0, 0, height);
                    blackGradient.addColorStop(0, "rgba(0, 0, 0, 0)");
                    blackGradient.addColorStop(1, "black");
                    ctx.fillStyle = blackGradient;
                    ctx.fillRect(0, 0, width, height);
                }

                function rgbToHex(r, g, b) {
                    const clamp = n => Math.max(0, Math.min(255, Math.round(n)));
                    return "#" + [r, g, b].map(clamp).map(n => n.toString(16).padStart(2, '0')).join('').toUpperCase();
                }

                function hueToRgb(h) {
                    h = h % 360;
                    let c = 255;
                    let x = Math.floor((1 - Math.abs((h / 60) % 2 - 1)) * 255);

                    if (h < 60) return [c, x, 0];
                    if (h < 120) return [x, c, 0];
                    if (h < 180) return [0, c, x];
                    if (h < 240) return [0, x, c];
                    if (h < 300) return [x, 0, c];

                    return [c, 0, x];
                }

                function getPixelRGB(x, y) {
                    const pixel = ctx.getImageData(x, y, 1, 1).data;
                    const [r, g, b] = pixel;
                    return {r, g, b };
                }

                function updatePreviewColor(r, g, b) {
                    previewBox.style.background = `rgb(${r}, ${g}, ${b})`;
                }

                function closePicker() {
                    popup.style.display ='none';
                }

                function applyHexInput(label, index) {
                    let hex = label.textContent.trim();

                    if (!hex.startsWith('#')) hex = '#' + hex;

                    if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                        colorBlocks[index].style.background = hex;
                        label.textContent = hex.toUpperCase();
                    } else {
                        const currentColor = window.getComputedStyle(colorBlocks[index]).backgroundColor;
                        const rgb = currentColor.match(/\d+/g).map(Number);
                        const fallbackHex = '#' + rgb.map( n => n.toString(16).padStart(2, "0")).join('').toUpperCase();
                        label.textContent = fallbackHex.toUpperCase();
                        alert("Invalid hex code")
                    }
                    label.contentEditable = false;
                }

                canvas.addEventListener('click',(e) =>{
                    const rect = canvas.getBoundingClientRect();

                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;

                    const x = Math.floor(e.clientX - rect.left) * scaleX;
                    const y = Math.floor(e.clientY - rect.top) * scaleY;

                    const {r, g, b} = getPixelRGB(x, y);
                    updatePreviewColor(r, g, b);

                    currentBaseColor = `rgb(${r}, ${g}, ${b})`;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!dragging) return;

                    const rect = hueBar.getBoundingClientRect();
                    let x = e.clientX - rect.left;
                    x = Math.max(0, Math.min(rect.width, x));

                    const percent = (x / rect.width) * 100;

                    hueHandle.style.left = percent + "%";

                    hue = Math.round((x / rect.width) * 360);
                    drawSpectrum()
                });

                hueBar.addEventListener('click', (e) => {
                    const rect = hueBar.getBoundingClientRect();
                    let x = e.clientX - rect.left;
                    x = Math.max(0, Math.min(rect.width, x));

                    hueHandle.style.left = `${(x / rect.width) * 100}%`;
                    hue = Math.round((x / rect.width) * 360);
                    drawSpectrum();
                });

                confirmButton.addEventListener('click', () => {
                    const rgb = previewBox.style.background.match(/\d+/g).map(Number);
                    const [r, g, b] = rgb
                   
                    const hex = "#" +
                                r.toString(16).padStart(2, "0").toUpperCase() +
                                g.toString(16).padStart(2, "0").toUpperCase() +
                                b.toString(16).padStart(2, "0").toUpperCase();

                    selectedBox.style.background = `rgb(${r}, ${g}, ${b})`;
                    hexLabels[selectedIndex].textContent = hex;

                    closePicker();
                });

                hexLabels.forEach((label, i) => {
                    label.addEventListener('click', () => {
                        label.contentEditable = true;
                        label.focus();
                    });

                    label.addEventListener('blur', () => {
                        applyHexInput(label, i);
                    });

                    label.addEventListener('keydown', () =>{
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            label.blur();
                        }
                    });
                });

                generateColors();
            </script>




        </div>

        <footer>
            <span class="footer_name">Â© Kaylee Hinton. All rights reserved.</span>
        </footer>

    </body>

</html>